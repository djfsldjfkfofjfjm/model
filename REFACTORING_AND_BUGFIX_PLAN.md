# План рефакторинга, исправления багов и улучшения проекта Financial Dashboard

Дата: 20.05.2025

## Введение

На основе проведенного детального анализа кода (см. `PROJECT_ANALYSIS_NEW.md` и `PROJECT_ANALYSIS_AI_VALIDATION.md`) выявлен ряд проблем, включая неполноту расчетов, неработающую функциональность, потенциальные проблемы с производительностью и управлением состоянием, а также недостаточное и некорректное тестовое покрытие. Этот план описывает этапы работ по устранению этих проблем и улучшению проекта.

## Общие принципы

*   **Итеративность**: Работы будут разбиты на логические этапы.
*   **Тестирование**: Каждый этап должен сопровождаться написанием/обновлением тестов. Сначала будут исправлены существующие тесты, затем будут добавляться новые для покрытия изменяемой/добавляемой функциональности.
*   **Приоритезация**: В первую очередь будут исправляться критические баги (нерассчитываемые метрики, неработающий ФОТ), затем будут проводиться улучшения и рефакторинг.

## Этап 0: Подготовка и исправление тестов

**Цель**: Обеспечить надежную основу для дальнейших изменений путем исправления текущей тестовой базы.

1.  **Рефакторинг `calculateFinancialModel.test.ts`**:
    *   Удалить скопированную/упрощенную логику `calculateFinancialModel` из тестового файла.
    *   Изменить тесты для использования **оригинального** хука `useFinancialModel` из `src/hooks/useFinancialModel.ts`. Это может потребовать обертывания вызова `renderHook` в `FinancialProvider` или мокирования зависимостей, если хук их использует неявно (хотя он принимает параметры явно).
    *   **Ожидаемый результат**: Тесты проверяют актуальную логику расчетов.
2.  **Рефакторинг `SettingsGraphsInteraction.test.tsx`**:
    *   Удалить мок-компоненты `SettingsGraphsTest` и `ClientsDataTest`.
    *   Переписать тесты для проверки взаимодействия **реальных компонентов** (`App` или `FinancialDashboard` внутри `FinancialProvider`).
    *   Симулировать действия пользователя (клики, ввод) и проверять обновление реальных элементов UI.
    *   Исправить ESLint ошибки `testing-library/no-wait-for-multiple-assertions`.
    *   **Ожидаемый результат**: Тесты проверяют реальное сквозное взаимодействие UI.
3.  **Проверка и обновление остальных тестов**:
    *   Просмотреть тесты для `App.tsx`, `EditableCell.tsx`, `InfoTooltip.tsx`, `MetricCard.tsx`, `FinancialContext.test.tsx`.
    *   Убедиться, что они актуальны и корректны. При необходимости обновить.
    *   **Ожидаемый результат**: Базовые компонентные и контекстные тесты надежны.

## Этап 1: Исправление критических багов в расчетах и UI

**Цель**: Обеспечить корректный расчет и отображение всех заявленных в UI метрик и данных.

1.  **Реализация расчета недостающих KPI и данных в `useFinancialModel.ts`**:
    *   Добавить расчеты для следующих полей в `TotalData`:
        *   `roi`, `finalActiveClients`, `totalChurnedClients`, `churnRate` (как свойство `totalData`), `implementationMargin`, `breakevenMonth`, `nrr` (агрегированный), `expansionRevenue` (агрегированный), `churnedRevenue` (агрегированный).
        *   Детализация Upsell: `totalAdditionalBotsRevenue`, `totalNewFeaturesRevenue`, `totalMessageExpansionRevenue`, `totalAdditionalIntegrationsRevenue`.
    *   Добавить расчеты для следующих полей в `MonthlyData`:
        *   `cumulativeProfit`, `cumulativeRevenue`, `cumulativeExpenses`.
        *   (Опционально, если нужно для UI/логики) `churnedClients` (общее), `totalMessagesInPackages`, `usedMessages` (общее), `unusedMessages` (общее), `carriedOverMessages`, `additionalMessagesNeeded`.
    *   **Тестирование**: Написать новые юнит-тесты в `calculateFinancialModel.test.ts` для каждой добавленной метрики и логики.
    *   **Ожидаемый результат**: `useFinancialModel` возвращает полные и корректные `monthlyData` и `totalData`.
2.  **Обновление типов `MonthlyData` и `TotalData`**:
    *   Сделать поля, которые теперь всегда рассчитываются, обязательными (убрать `?`).
    *   Убедиться, что типы точно отражают структуру возвращаемых данных.
    *   **Ожидаемый результат**: Типы данных консистентны с реализацией.
3.  **Исправление отображения в UI компонентах**:
    *   Убедиться, что `KeyMetricsPanel.tsx`, `UpsellSettingsPanel.tsx`, `RevenueChart.tsx`, `KPIRadarChart.tsx` корректно используют обновленные данные из `totalData` и `monthlyData`.
    *   Удалить или заменить заглушки/дефолтные значения там, где теперь есть реальные данные.
    *   **Тестирование**: Обновить/добавить интеграционные тесты в `SettingsGraphsInteraction.test.tsx` (или аналогичных) для проверки корректного отображения этих метрик.
    *   **Ожидаемый результат**: UI корректно отображает все рассчитанные метрики.
4.  **Реализация редактирования ФОТ**:
    *   Добавить состояния для `fotOptimistic: number[]` и `fotPessimistic: number[]` в `FinancialContext.tsx`.
    *   Реализовать сеттеры-обертки для них, вызывающие пересчет модели.
    *   Передать эти состояния в `modelParams` (или создать новый объект параметров для ФОТ, например `fotData`).
    *   Изменить `useFinancialModel.ts`, чтобы он принимал и использовал эти редактируемые значения ФОТ вместо `DEFAULT_FOT_VALUES`.
    *   Обновить `FOTEditor.tsx` для использования этих состояний и сеттеров, убрав заглушки.
    *   **Тестирование**: Добавить юнит-тесты для новой логики ФОТ в `calculateFinancialModel.test.ts` и интеграционные тесты для `FOTEditor.tsx`.
    *   **Ожидаемый результат**: Пользователи могут редактировать ФОТ, и это влияет на расчеты модели.

## Этап 2: Улучшение управления состоянием и производительности

**Цель**: Оптимизировать обновление состояния и механизм пересчета для повышения производительности и предсказуемости.

1.  **Рефакторинг управления состоянием в `FinancialContext.tsx`**:
    *   Рассмотреть использование `useReducer` для управления всеми параметрами модели (`modelParams`, `clientsData`, `upsellSettings`) как единым объектом состояния или несколькими крупными объектами.
    *   Цель: сделать объекты `modelParams`, `clientsData`, `upsellSettings` более стабильными, чтобы они не пересоздавались при каждом рендере `FinancialProvider`, если их содержимое не изменилось.
    *   **Тестирование**: Существующие интеграционные тесты должны помочь проверить, что поведение не сломалось. Могут потребоваться специфичные тесты для `FinancialContext`.
    *   **Ожидаемый результат**: Уменьшение лишних пересозданий объектов и функции `calculateFinancialModel`.
2.  **Изменение механизма запуска пересчета**:
    *   Заменить вызовы `setTimeout(calculateFinancialModel, 0)` на использование `useEffect` в `FinancialContext.tsx`.
    *   Этот `useEffect` должен зависеть от всех параметров модели (или от объектов `modelParams`, `clientsData`, `upsellSettings`, если они стали стабильными).
    *   Пересчет должен происходить синхронно при изменении зависимостей.
    *   Убрать `eslint-disable-next-line react-hooks/exhaustive-deps` из `useEffect` для первоначального расчета, обеспечив корректные зависимости.
    *   **Тестирование**: Проверить, что модель корректно пересчитывается при изменении любого параметра и при первоначальной загрузке.
    *   **Ожидаемый результат**: Более предсказуемый и потенциально более производительный механизм пересчета.

## Этап 3: Рефакторинг и очистка кода

**Цель**: Улучшить читаемость, поддерживаемость и качество кода.

1.  **Декомпозиция `useFinancialModel.ts`**:
    *   Разбить монолитную функцию `calculateFinancialModel` на более мелкие, логически сгруппированные чистые функции (например, `calculateRevenue`, `calculateExpenses`, `calculateClientMetrics` и т.д.).
    *   **Тестирование**: Юнит-тесты для каждой новой выделенной функции.
    *   **Ожидаемый результат**: Улучшение читаемости и тестируемости логики расчетов.
2.  **Удаление неиспользуемого кода**:
    *   Удалить устаревший файл `src/FinancialDashboard.tsx`.
    *   Устранить все предупреждения ESLint о неиспользуемых переменных и импортах в актуальных файлах.
    *   **Тестирование**: Убедиться, что удаление кода не повлияло на функциональность.
    *   **Ожидаемый результат**: Более чистая кодовая база.
3.  **Проверка и улучшение типизации**:
    *   Проанализировать использование `any` (если есть) и постараться заменить на более строгие типы.
    *   Убедиться, что все опциональные поля в типах действительно могут отсутствовать или имеют проверки на `undefined` при использовании.
    *   **Ожидаемый результат**: Повышение надежности кода за счет строгой типизации.

## Этап 4: Дополнительные улучшения (по возможности)

*   **Расширение тестового покрытия**: Добавить больше граничных случаев и сценариев в тесты.
*   **Оптимизация рендеринга**: Проанализировать и оптимизировать рендеринг компонентов, если будут выявлены проблемы с производительностью UI (например, с помощью React DevTools Profiler).
*   **Улучшение UX**: Рассмотреть мелкие улучшения пользовательского интерфейса на основе анализа.

## Заключение

Этот план представляет собой дорожную карту для улучшения проекта. Порядок и содержание этапов могут корректироваться в зависимости от открывающихся деталей и приоритетов. Ключевым аспектом является обеспечение и поддержка адекватного тестового покрытия на всех этапах.
